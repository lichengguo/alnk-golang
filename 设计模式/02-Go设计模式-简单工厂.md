### 简单工厂模式

#### 示例代码

```go
/*
简单工厂模式角色和职责

工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。
抽象产品（AbstractProduct）角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。
具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例对象。

优点：
1. 实现了对象创建和使用的分离。
2. 不需要记住具体类名，记住参数即可，减少使用者记忆量。

缺点：
1. 对工厂类职责过重，一旦不能工作，系统受到影响。
2. 增加系统中类的个数，复杂度和理解度增加。
3. 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。

适用场景：
1.  工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
2. 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。
*/

package _0_simple_factory

//----------------- 抽象层 -------------------------

//水果类(抽象接口)
type Fruit interface {
	Show() string //接口的某方法
}

//---------------- 基础类模块 ----------------------

//Apple ...
type Apple struct {
	//其他参数
	//其他参数
}

func (a *Apple) Show() string {
	return "我是苹果"
}

//Banana ...
type Banana struct {
	//其他参数
	//其他参数
}

func (b *Banana) Show() string {
	return "我是香蕉"
}

//Pear ...
type Pear struct {
	//其他参数
	//其他参数
}

func (p *Pear) Show() string {
	return "我是梨子"
}

//----------------- 工厂模块 ----------------------
//一个工厂，有一个生产水果的机器，返回一个抽象水果的指针
type Factory struct{}

func (f *Factory) CreateFruit(kind string) Fruit {
	var fruit Fruit

	switch kind {
	case "apple":
		fruit = new(Apple)
	case "banana":
		fruit = new(Banana)
	case "pear":
		fruit = new(Pear)
	}

	return fruit
}

```





#### 测试代码

```go
package _0_simple_factory

import "testing"

func TestType1(t *testing.T) {
	var f Factory
	if f.CreateFruit("banana").Show() != "我是香蕉" {
		t.Fatal("error")
	}
}
```
