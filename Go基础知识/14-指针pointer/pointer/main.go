package main

import "fmt"

/*
[pointer指针]
参考博客地址:https://www.liwenzhou.com/posts/Go/07_pointer/

Go语言中的指针不能进行偏移和运算，是安全指针

要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值


[Go语言中的指针]
任何程序数据载入内存后，在内存都有他们的地址，这就是指针.而为了保存一个数据在内存中的地址，我们就需要指针变量

比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），
我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。
这时候变量B就是一个指针变量。
通过变量A和变量B都能找到我的座右铭

Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：
&（取地址）和 *（根据地址取值）

总结： 取地址操作符&和取值操作符*是一对互补操作符，&取出地址，*根据地址取出地址指向的值

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：
	对变量进行取地址（&）操作，可以获得这个变量的指针变量。 //a := 10  b := &a
	指针变量的值是指针地址。 //b的值是指针地址
	对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。  // *b  的值是10


[new和make]
在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。
而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。

要分配内存，就引出来今天的new和make
Go语言中new和make是内建的两个函数，主要用来分配内存

new
new是一个内置的函数，它的函数签名如下：
func new(Type) *Type
Type表示类型，new函数只接受一个参数，这个参数是一个类型
*Type表示类型指针，new函数返回一个指向该类型内存地址的指针
new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值
func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}

make
make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，
因为这三种类型就是引用类型，所以就没有必要返回他们的指针了
make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作

new与make的区别
	二者都是用来做内存分配的
	make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身
	new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针
*/

func main() {
	var a int
	a = 100
	b := &a //b是获取了a的内存地址  指针
	//fmt.Printf("type  a:%T  type b:%T\n", a, b)
	//fmt.Println("b:", b) //0xc000018080

	//
	fmt.Printf("%p\n", &a) //a的内存地址或者说指针 	0xc000018080
	fmt.Printf("%p\n", b)  //a的内存地址或者说指针 	0xc000018080

	fmt.Printf("%#v\n", b) //b的值 (*int)(0xc000018080) b这个变量存储的值就是a的内存地址
	fmt.Printf("%p\n", &b) //b自己本身内存地址	0xc0000ae018
	fmt.Printf("%v\n", *b) //100 查找b这个变量的值（a的内存地址）   所指向的值
}
