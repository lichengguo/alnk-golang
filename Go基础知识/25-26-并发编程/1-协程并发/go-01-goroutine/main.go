package main

import (
	"fmt"
	"time"
)

/*
[进程，线程，协程的区别是什么]
进程是操作系统中进行资源分配和调度的基本单位，它拥有自己的独立内存空间和系统资源
每个进程都有独立的堆和栈，不与其他进程共享
进程间通信需要通过特定的机制，如管道、消息队列、信号量等
由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销也较大，因为需要保存和恢复整个进程的状态

线程是进程内的一个执行单元，也是CPU调度和分派的基本单位
与进程不同，线程共享进程的内存空间，包括堆和全局变量
线程之间通信更加高效，因为它们可以直接读写共享内存
线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态
然而，由于多个线程共享内存空间，因此存在数据竞争和线程安全的问题，需要通过同步和互斥机制来解决

协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与
协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存
协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换
这使得协程在处理大量并发任务时具有非常高的效率
然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂


[并发与并行]
并发: 同一时间段内 执行多个任务
并行: 同一时刻    执行多个任务


[golang goroutine原理]
GMP模型
G   goroutine协程     	 用户态
P   processor携程调度器   用户态
M   thread线程        	 内核态


[goroutine]
Go语言的并发通过goroutine实现，goroutine类似于线程，属于用户态的线程，比内核态线程更轻量级，是由Go语言的运行时(runtime)调度的
Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU
Go语言之所以被称为现代化的编程语言 就是因为它在语言层面已经内置了调度和上下文切换的机制
Go语言还提供channel在多个goroutine间进行通信
Go语言中使用goroutine非常简单 只需要在调用函数的时候在前面加上go关键字 就可以为一个函数创建一个goroutine
一个goroutine必定对应一个函数 可以创建多个goroutine去执行相同的函数


[goroutine什么结束]
goroutine 对应的函数结束了 goroutine结束了 
main函数执行完了 由main函数创建的那些goroutine都结束了
*/

func hello(i int) {
	fmt.Println("hello ", i)
}

// 在程序启动时, Go程序就会为main()函数创建一个默认的goroutine
func main() {
	// 启动多个goroutine
	for i := 0; i < 10; i++ {
		go hello(i) // 开启一个单独的goroutine去执行hello函数（任务）
	}
	fmt.Println("main")

	// 如果main函数结束，那么由main函数启动的goroutine也都结束了
	// 所以在这里等待1s，等其他的goroutine执行完毕在结束
	time.Sleep(time.Second)
}
