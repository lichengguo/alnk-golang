package main

import "fmt"

/*
[close关闭通道]
关闭一个通道意味着不能再向这个通道发送值了
该特性可以向通道的接收方传达工作已经完成的信息

关于关闭通道需要注意的事情
1. 只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道
2. 如果一个通道没有关闭，那么通道中数据读取到最后会出现死锁，如果关闭了则不会
3. 通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的

关闭后的通道有以下特点：
1. 对一个关闭的通道再发送值就会导致panic
2. 对一个关闭的通道进行接收会一直获取值直到通道为空
3. 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值
4. 关闭一个已经关闭的通道会导致panic
*/

func main() {
	// 创建一个整型的通道
	ch := make(chan int)

	// 启动一个并发任务，向通道发送整型值
	go func() {
		for i := 0; i < 5; i++ {
			fmt.Printf("发送: %d\n", i)
			ch <- i // 发送整型值
		}
		// 发送完数据后关闭通道
		close(ch)
		fmt.Println("数据发送完毕，关闭通道")
	}()

	// 从通道接收值, 直到通道关闭
	for {
		// 尝试从通道接收值
		v, ok := <-ch
		if !ok {
			fmt.Println("通道已关闭，没有数据可接收")
			break
		}
		fmt.Printf("接收到的数据: %d\n", v)
	}

	// 主函数继续执行其他操作
	fmt.Println("主函数继续执行...")
}
