### 工厂方法模式

#### 示例代码

```go
/*
工厂方法模式
抽象工厂（Abstract Factory）角色：工厂方法模式的核心，任何工厂类都必须实现这个接口
工厂（Concrete Factory）角色：具体工厂类是抽象工厂的一个实现，负责实例化产品对象
抽象产品（Abstract Product）角色：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口
具体产品（Concrete Product）角色：工厂方法模式所创建的具体实例对象
简单工厂模式  + “开闭原则” =  工厂方法模式

优点：
1. 不需要记住具体类名，甚至连具体参数都不用记忆。
2. 实现了对象创建和使用的分离。
3. 系统的可扩展性也就变得非常好，无需修改接口和原类。
4.对于新产品的创建，符合开闭原则。

缺点：
1. 增加系统中类的个数，复杂度和理解度增加。
2. 增加了系统的抽象性和理解难度。


适用场景：
1. 客户端不知道它所需要的对象的类。
2. 抽象工厂类通过其子类来指定创建哪个对象。
*/

package _1_factory_method

//-------------- 抽象层 ----------------------------------------------------

//水果类(抽象接口)
type Fruit interface {
	Show() string //接口的某个方法
}

//工厂类(抽象接口)
type AbstractFactory interface {
	CreateFruit() Fruit //生产水果类(抽象)的生产器方法
}

//-------------- 基础模块类 ------------------------------------------

//Apple ...
type Apple struct {
	//其他参数
}

func (a *Apple) Show() string {
	return "我是苹果"
}

//Banana ...
type Banana struct {
	//其他参数
}

func (b *Banana) Show() string {
	return "我是香蕉"
}

//Pear ...
type Pear struct {
	//其他参数
}

func (p *Pear) Show() string {
	return "我是梨子"
}

//-------------------------- 工厂模块 ----------------------------------
//AppleFactory 具体的苹果工厂
type AppleFactory struct {
	//其他参数
}

func (fac *AppleFactory) CreateFruit() Fruit {
	var fruit Fruit

	//生产一个具体的苹果
	fruit = new(Apple)

	return fruit
}

//BananaFactory 具体的香蕉工厂
type BananaFactory struct {
	//其他参数
}

func (fac BananaFactory) CreateFruit() Fruit {
	var fruit Fruit

	//生产一个具体的香蕉
	fruit = new(Banana)

	return fruit
}

//PearFactory 具体的梨工厂
type PearFactory struct {
	//其他参数
}

func (fac *PearFactory) CreateFruit() Fruit {
	var fruit Fruit

	//生产一个具体的梨
	fruit = new(Pear)

	return fruit
}

//----------------------------------- 构造函数 ---------------------------------
func NewFruit(abs AbstractFactory) Fruit {
	return abs.CreateFruit()
}

//----------------------------------------------------------------------------------
//------------------------------------ 新增一个需求 日本苹果 ---------------------------
//-------------------------- 基础模块 ------------------------------------------------
//JapanApple ...
type JapanApple struct {
	//其他参数
}

func (j *JapanApple) Show() string {
	return "日本苹果"
}

//------------------------ 工厂模块 --------------------------------------------------
type JapanAppleFactory struct {
	//其他参数
}

func (fac *JapanAppleFactory) CreateFruit() Fruit {
	var fruit Fruit

	//生产一个日本苹果
	fruit = new(JapanApple)

	return fruit
}

```





#### 测试代码

```go
package _1_factory_method

import "testing"

func TestApple(t *testing.T) {
	//1 先要一个具体的苹果工厂
	var appleFac AbstractFactory
	appleFac = new(AppleFactory)

	//2 生产相对应的具体水果
	var apple Fruit
	apple = appleFac.CreateFruit()

	if apple.Show() != "我是苹果" {
		t.Fatal("erro")
	}
}

func TestBanana(t *testing.T) {
	//具体工厂
	var bananaFactory BananaFactory

	//生产相应水果
	if NewFruit(bananaFactory).Show() != "我是香蕉" {
		t.Fatal("error")
	}
}

```
